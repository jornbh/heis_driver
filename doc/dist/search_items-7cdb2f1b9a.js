searchNodes=[{"ref":"Driver.html","title":"Driver","type":"module","doc":"An elixir-driver communicating with &#39;SimElevatorServer&#39; or the elevator server. Description You must start the driver with start_link() or start_link(ip_address, port) before any of the other functions will work. The user is responsible for not giving stupid input, or polling nonexistent buttons Including the driver in projects Elixir Modify the deps-list in mix.exs, do that it includes defp deps do [ {:heis_driver, git: &quot;https://github.com/jornbh/heis_driver.git&quot;, tag: &quot;0.1.0&quot;} ] end Erlang You need some extra plugins to include elixir-code. {plugins, [rebar_mix]}. {provider_hooks, [{post, [{compile, {mix, consolidate_protocols}}]}]}. This makes it possible to include elixir-dependencies. Afterwards, modify the line for deps in rebar.config, so that it becomes: {deps, [ {heis_driver, {git, &quot;git://github.com/jornbh/heis_driver.git&quot;, {tag, &quot;0.1.0&quot;}}} ]}. You might have to call the dunctions like &#39;Elixir.Driver&#39;:&#39;button_pressed?&#39;(1, hall_up) if the names do not follow the conventions for atoms in Erlang. Further reading GenServers are a really neat way to make servers without having to rewrite the same code all the time. It works Exactly the same in erlang as well, but it is called gen_server instead. The erlang documentation is kind of hard understand, so use the elixir-video and &quot;Translate&quot; it to erlang (gen_server:call(...) instead of GenServer.call(...)). Short version is that a GenServer implements the basic parts of a server, and the code seen in this file is the &quot;Blanks you have to fill in&quot; A youtube-video that explains GenServers and Supervisors https://www.youtube.com/watch?v=3EjRvaCOl94 Credits to Jostein for implementing this"},{"ref":"Driver.html#button_pressed?/2","title":"Driver.button_pressed?/2","type":"function","doc":""},{"ref":"Driver.html#child_spec/1","title":"Driver.child_spec/1","type":"function","doc":"Returns a specification to start this module under a supervisor. See Supervisor."},{"ref":"Driver.html#child_spec/2","title":"Driver.child_spec/2","type":"function","doc":""},{"ref":"Driver.html#poll_floor_sensor/0","title":"Driver.poll_floor_sensor/0","type":"function","doc":""},{"ref":"Driver.html#set_button_light/3","title":"Driver.set_button_light/3","type":"function","doc":""},{"ref":"Driver.html#set_door_state/1","title":"Driver.set_door_state/1","type":"function","doc":""},{"ref":"Driver.html#set_floor_indicator/1","title":"Driver.set_floor_indicator/1","type":"function","doc":""},{"ref":"Driver.html#set_motor_dir/1","title":"Driver.set_motor_dir/1","type":"function","doc":""},{"ref":"Driver.html#start_link/0","title":"Driver.start_link/0","type":"function","doc":""},{"ref":"Driver.html#start_link/2","title":"Driver.start_link/2","type":"function","doc":""},{"ref":"Driver.html#t:button_dir/0","title":"Driver.button_dir/0","type":"type","doc":""},{"ref":"Driver.html#t:ip_address/0","title":"Driver.ip_address/0","type":"type","doc":""},{"ref":"Driver.html#t:motor_dir/0","title":"Driver.motor_dir/0","type":"type","doc":""},{"ref":"readme.html","title":"Elixir elevator driver","type":"extras","doc":"Elixir elevator driver"},{"ref":"readme.html#documetnation","title":"Elixir elevator driver - Documetnation","type":"extras","doc":"All functions are documented in the link"},{"ref":"readme.html#how-to-include-the-modules-in-your-project","title":"Elixir elevator driver - How to include the modules in your project","type":"extras","doc":"If you are using Mix as you Elixir build tool (which you really should), go into mix.exs and modify the function deps to contain defp deps do [ {:heis_driver, git: &quot;https://github.com/jornbh/heis_driver.git&quot;, tag: &quot;0.1.2&quot;} ] end Modify the tag to correspond to a newer release if some bugfixes are added later. The driver should be available as a module named Driver, just like your normal modules."},{"ref":"readme.html#using-the-driver-in-erlang","title":"Elixir elevator driver - Using the driver in Erlang","type":"extras","doc":"If you are using rebar3, downloading the dependency is somewhat similar, but you need a plugin. Just add/modify the lines for plugins and provider_hooks in rebar.config, so that they look like this {plugins, [rebar_mix]}. {provider_hooks, [{post, [{compile, {mix, consolidate_protocols}}]}]}. This makes it possible to include elixir-dependencies. Afterwards, modify the line for deps, so that it becomes: {deps, [ {heis_driver, {git, &quot;git://github.com/jornbh/heis_driver.git&quot;, {tag, &quot;0.1.2&quot;}}} ]}. Now, you will have to write call the module, which will be an atom that starts With &quot;Elixir.&quot;, and the rest is just the normal module name. If the function has problematic signs, use the same type of quotes around it as well. &#39;Elixir.Driver&#39;:set_door_state(closed). &#39;Elixir.Driver&#39;:&#39;button_pressed?&#39;(1, hall_up)."},{"ref":"readme.html#further-reading","title":"Elixir elevator driver - Further reading","type":"extras","doc":"GenServers are a really neat way to make servers without having to rewrite the same code all the time. It works Exactly the same in Erlang as well, but it is called gen_server instead. The erlang documentation is kind of difficult to understand, so use the elixir-video and &quot;Translate&quot; it to Erlang (gen_server:call(...) instead of GenServer.call(...)). The short version is that a GenServer implements the basic parts of a server, and the code that is seen in this file is the &quot;Blanks&quot; you have to fill in A youtube-video that explains GenServers and Supervisors https://www.youtube.com/watch?v=3EjRvaCOl94"}]